library (mc2d)
pert_hours = NULL
for (i in 1:nrow (tasks)){
pert_hours = c(pert_hours, qpert (0.8, tasks$Min_Hours[i], tasks$Most_Likely_Hours[i], tasks$Max_Hours[i]))
}
tasks$pert_hours = pert_hours
time_now = now()
tasks$hours_to_deadline = as.numeric (ymd_hms (tasks$Deadline) - time_now)
tasks$hours_remaining_percent_work = tasks$hours_to_deadline / tasks$pert_hours
tasks = tasks [order (tasks$hours_remaining_percent_work)]
tasks
tasks
tasktasks$hours_remaining_percent_work = tasks$hours_to_deadline / tasks$pert_hours
tasks$percent_work_rem = tasks$hours_to_deadline / tasks$pert_hours
tasks
tasks = tasks [order (tasks$percent_work_rem)]
tasks
tasks = read.csv ("all_tasks.csv", as.is = TRUE)
tasks = tasks [!is.na (tasks$Most_Likely_Hours),]
library (lubridate)
library (mc2d)
pert_hours = NULL
for (i in 1:nrow (tasks)){
pert_hours = c(pert_hours, qpert (0.8, tasks$Min_Hours[i], tasks$Most_Likely_Hours[i], tasks$Max_Hours[i]))
}
tasks$pert_hours = pert_hours
time_now = now()
tasks$hours_to_deadline = as.numeric (ymd_hms (tasks$Deadline) - time_now)
tasks$percent_work_rem = tasks$hours_to_deadline / tasks$pert_hours
tasks = tasks [order (tasks$percent_work_rem),]
tasks
tasks$order = 1:nrow (tasks)
tasks
start_ooo = dmy_hm ("29/04/2020 15:00")
end_ooo = dmy_hm ("29/04/2020 16:00")
ooos <- data.frame (start = start_ooo, end = end_ooo)
ooos = rbind (ooos, data.frame (start = dmy_hm ("29/04/2020 17:00"), end = dmy_hm ("30/04/2020 09:00")))
ooos
tasks$pert_hours
tasks$pert_hours[1]
adjust_times(current_start, tasks$pert_hours[1],ooos)
library (dplyr)
adjust_times(current_start, tasks$pert_hours[1],ooos)
current_start= time_now
adjust_times(current_start, tasks$pert_hours[1],ooos)
tasks$pert_hours[1]
current_start
ymd_hms (current_start)
ymd_hms (current_start) + hours (tasks$pert_hours[1])
ymd_hms (current_start) + hours (round (tasks$pert_hours[1]*60))
adjust_times(current_start, round (tasks$pert_hours[1]*60), ooos)
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[1]*60), ooos)
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[1]*60), ooos)
current_start = adjusted_start_finish[1]
current_finish = adjusted_start_finish[2]
current_finish
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
current_finish
current_start
library (lubridate)
library (tidyr)
library (reticulate)
reticulate::source_python ("time_cal_api.py")
#Needs a dataframe with 'start' and 'end' dates as dates
merge_overlapping_times <- function (df) {
df = df %>%
mutate(indx = c(0, cumsum(as.numeric(lead(start)) >
cummax(as.numeric(end)))[-n()])) %>%
group_by(indx) %>%
summarise(start = min(start), end = max(end))
return (as.data.frame (df[,c("start", "end")]))
}
adjust_start_times <- function (start_time, hours_to_add, start_ooo, end_ooo){
curr_start_time = start_time
curr_end_time = curr_start_time + hours (hours_to_add)
#If a task is due to start within an OOO, move it to start after the OOO
if ((curr_start_time >= start_ooo) & (curr_start_time < end_ooo)){
#print ("start within ooo")
curr_start_time = end_ooo
curr_end_time = curr_start_time + hours (hours_to_add)
}
return (list (curr_start_time, curr_end_time))
}
adjust_end_times <- function (start_time, minites_to_add, start_ooo, end_ooo){
curr_start_time = start_time
curr_end_time = curr_start_time + minutes (minites_to_add)
#If the end time falls within an ooo, move it to be after the end of the ooo by
#the amount that it's currrently within it
if ((curr_end_time > start_ooo) & (curr_end_time < end_ooo)){
#print ("end within ooo")
curr_end_time = end_ooo + minutes (curr_end_time - start_ooo)
}  else if ((curr_start_time <= start_ooo) & (curr_end_time >= end_ooo)){   #If the ooo falls within the task, add the ooo length to the current end time
#print ("fully within")
ooo_length = end_ooo - start_ooo
#diff_to_add = task_length - ((start_ooo - curr_start_time) + (curr_end_time - end_ooo))
diff_to_add = ooo_length - (start_ooo - curr_start_time)# + (curr_end_time - end_ooo))
#print (diff_to_add)
curr_end_time = curr_end_time + ooo_length #hours (diff_to_add)#ooo_length) #hours (diff_to_add)
}
return (list (curr_start_time, curr_end_time))
}
adjust_times <- function (current_start_time, minites_to_add, ooos){
ooos = merge_overlapping_times(ooos)
ooos = ooos [order (ooos$start),]
for (ooo in ooos){
adjusted_times = adjust_start_times (current_start_time, minites_to_add, ooo[1], ooo[2])
current_start_time= adjusted_times[[1]]
current_end_time= adjusted_times[[2]]
}
# current_start_time
# current_end_time
ooos = ooos [order (ooos$end),]
for (ooo in ooos){
adjusted_times = adjust_end_times (current_start_time, minites_to_add, ooo[1], ooo[2])
current_start_time= adjusted_times[[1]]
current_end_time= adjusted_times[[2]]
}
return (list (current_start_time, current_end_time))
}
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[1]*60), ooos)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
current_start
current_finish
round (tasks$pert_hours[1]*60)
task_finishes = NULL
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[i]*60), ooos)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, current_start)
task_finishes = c(task_finishes, current_finish)
}
task_starts
task_finishes
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[i]*60), ooos)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
task_starts
current_finish
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
print (current_start)
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[i]*60), ooos)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
tasks$pert_hours
library (lubridate)
library (tidyr)
library (reticulate)
#reticulate::source_python ("time_cal_api.py")
#Needs a dataframe with 'start' and 'end' dates as dates
merge_overlapping_times <- function (df) {
df = df %>%
mutate(indx = c(0, cumsum(as.numeric(lead(start)) >
cummax(as.numeric(end)))[-n()])) %>%
group_by(indx) %>%
summarise(start = min(start), end = max(end))
return (as.data.frame (df[,c("start", "end")]))
}
adjust_start_times <- function (start_time, minutes_to_add, start_ooo, end_ooo){
curr_start_time = start_time
curr_end_time = curr_start_time + minutes (minutes_to_add)
#If a task is due to start within an OOO, move it to start after the OOO
if ((curr_start_time >= start_ooo) & (curr_start_time < end_ooo)){
#print ("start within ooo")
curr_start_time = end_ooo
curr_end_time = curr_start_time + minutes (minutes_to_add)
}
return (list (curr_start_time, curr_end_time))
}
adjust_end_times <- function (start_time, minutes_to_add, start_ooo, end_ooo){
curr_start_time = start_time
curr_end_time = curr_start_time + minutes (minutes_to_add)
#If the end time falls within an ooo, move it to be after the end of the ooo by
#the amount that it's currrently within it
if ((curr_end_time > start_ooo) & (curr_end_time < end_ooo)){
#print ("end within ooo")
curr_end_time = end_ooo + minutes (curr_end_time - start_ooo)
}  else if ((curr_start_time <= start_ooo) & (curr_end_time >= end_ooo)){   #If the ooo falls within the task, add the ooo length to the current end time
#print ("fully within")
ooo_length = end_ooo - start_ooo
#diff_to_add = task_length - ((start_ooo - curr_start_time) + (curr_end_time - end_ooo))
diff_to_add = ooo_length - (start_ooo - curr_start_time)# + (curr_end_time - end_ooo))
#print (diff_to_add)
curr_end_time = curr_end_time + ooo_length #hours (diff_to_add)#ooo_length) #hours (diff_to_add)
}
return (list (curr_start_time, curr_end_time))
}
adjust_times <- function (current_start_time, minutes_to_add, ooos){
ooos = merge_overlapping_times(ooos)
ooos = ooos [order (ooos$start),]
for (ooo in ooos){
adjusted_times = adjust_start_times (current_start_time, minutes_to_add, ooo[1], ooo[2])
current_start_time= adjusted_times[[1]]
current_end_time= adjusted_times[[2]]
}
# current_start_time
# current_end_time
ooos = ooos [order (ooos$end),]
for (ooo in ooos){
adjusted_times = adjust_end_times (current_start_time, minutes_to_add, ooo[1], ooo[2])
current_start_time= adjusted_times[[1]]
current_end_time= adjusted_times[[2]]
}
return (list (current_start_time, current_end_time))
}
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
print (current_start)
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[i]*60), ooos)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
current_start
current_finish
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
print (current_start)
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[i]*60), ooos)
print (adjusted_start_finish)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
#print (current_start)
adjusted_start_finish = adjust_times(current_start, round (tasks$pert_hours[i]*60), ooos)
print (adjusted_start_finish)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
#print (current_start)
adjusted_start_finish = adjust_times(adjusted_start_finish[[1]], round (tasks$pert_hours[i]*60), ooos)
print (adjusted_start_finish)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
task_starts = NULL
task_finishes = NULL
current_start= time_now
for (i in 1:nrow (tasks)){
#print (current_start)
adjusted_start_finish = adjust_times(current_finish, round (tasks$pert_hours[i]*60), ooos)
print (adjusted_start_finish)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
ooos
task_starts = NULL
task_finishes = NULL
current_finish= time_now
for (i in 1:nrow (tasks)){
#print (current_start)
adjusted_start_finish = adjust_times(current_finish, round (tasks$pert_hours[i]*60), ooos)
print (adjusted_start_finish)
current_start = adjusted_start_finish[[1]]
current_finish = adjusted_start_finish[[2]]
task_starts = c(task_starts, as.character (current_start))
task_finishes = c(task_finishes, as.character (current_finish))
}
task_starts
task$task_start = task_starts
task$task_finish = task_finishes
tasks$task_start = task_starts
tasks$task_finish = task_finishes
tasks
finish = "2020-05-08 17:00:00"
merge_overlapping_times(ooos)
ooos = merge_overlapping_times(ooos)
ooos
start
time_now
time_now - finish
time_now - ymd_hms (finish)
ymd_hms (finish) - time_now
minutes (ymd_hms (finish) - time_now)
ymd_hms (finish) - time_now
time_diff = ymd_hms (finish) - time_now
time_diff
time_diff / minutes (1)
time_diff$minutes
time_diff
minute (time_diff)
difftime
difftime (time_now, finish)
difftime (time_now, finish, "mins")
difftime (time_now, finish, units= "mins")
difftime (finish, time_now, units= "mins")
as.numeric (difftime (finish, time_now, units= "mins"))
time_diff_mins = as.numeric (difftime (finish, time_now, units= "mins"))
time_diff_mins
ooos
(ooos$start <= time_now) & (ooos$end > finish)
start = "2020-04-29 11:00:00"
finish = "2020-05-08 17:00:00"
ooos = merge_overlapping_times(ooos)
time_diff_mins = as.numeric (difftime (finish, time_now, units= "mins"))
(ooos$start <= time_now) & (ooos$end > finish)
(ooos$start <= start) & (ooos$end > finish)
(ooos$start <= ymd_hms (start)) & (ooos$end > ymd_hms (finish))
ooos
(ooos$start >= ymd_hms (start)) & (ooos$end < ymd_hms (finish))
(ooos$start >= ymd_hms (start)) & (ooos$end <= ymd_hms (finish))
ooos [(ooos$start >= ymd_hms (start)) & (ooos$end <= ymd_hms (finish)),]
ooos_to_add$start
ooos_to_add = ooos [(ooos$start >= ymd_hms (start)) & (ooos$end <= ymd_hms (finish)),]
ooos_to_add
ooos_to_add$start
ymd_hms (ooos_to_add$start)
ymd_hms (ooos_to_add$start) - ymd_hms (ooos_to_add$end)
ymd_hms (ooos_to_add$end) - ymd_hms (ooos_to_add$start)
difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins")
as.numeric (difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins"))
sum (as.numeric (difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins")))
total_ooo_mins
total_ooo_mins = sum (as.numeric (difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins")))
total_ooo_mins
ooos_to_add - total_ooo_mins
time_diff_mins - total_ooo_mins
tasks
tasks$task_finish [2]
start = "2020-04-29 11:00:00"
finish = tasks$task_finish [2] #"2020-05-08 17:00:00"
ooos = merge_overlapping_times(ooos)
time_diff_mins = as.numeric (difftime (finish, time_now, units= "mins"))
ooos_to_add = ooos [(ooos$start >= ymd_hms (start)) & (ooos$end <= ymd_hms (finish)),]
if (nrow (ooos_to_add) > 0){
total_ooo_mins = sum (as.numeric (difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins")))
}
time_diff_mins = time_diff_mins - total_ooo_mins
time_diff_mins
finish
time_diff_mins
start
finish
ooos = merge_overlapping_times(ooos)
time_diff_mins = as.numeric (difftime (finish, start, units= "mins"))
ooos_to_add = ooos [(ooos$start >= ymd_hms (start)) & (ooos$end <= ymd_hms (finish)),]
if (nrow (ooos_to_add) > 0){
total_ooo_mins = sum (as.numeric (difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins")))
}
time_diff_mins = time_diff_mins - total_ooo_mins
time_diff_mins
real_time_delta_mins <- function (start, finish, ooos){
ooos = merge_overlapping_times(ooos)
time_diff_mins = as.numeric (difftime (finish, start, units= "mins"))
ooos_to_add = ooos [(ooos$start >= ymd_hms (start)) & (ooos$end <= ymd_hms (finish)),]
total_ooo_mins =  0
if (nrow (ooos_to_add) > 0){
total_ooo_mins = sum (as.numeric (difftime (ymd_hms (ooos_to_add$end), ymd_hms (ooos_to_add$start), units = "mins")))
}
time_diff_mins = time_diff_mins - total_ooo_mins
return (time_diff_mins)
}
real_time_delta_mins
real_time_delta_mins (start, finish, ooos)
tasks
tasks$Most_Likely_Hours [1:1]
tasks$Most_Likely_Hours [1:2]
cum_most_likely = sum (tasks$Most_Likely_Hours [1:2])
cum_min = sum (tasks$Min_Hours [1:2])
cum_max = sum (tasks$Max_Hours [1:2])
real_time_available = real_time_delta_mins (start, finish, ooos)
ppert real_time_available, cum_min, cum_most_likely, cum_max)
ppert (real_time_available, cum_min, cum_most_likely, cum_max)
ppert (real_time_available/60, cum_min, cum_most_likely, cum_max)
real_min_available = real_time_delta_mins (start, finish, ooos)
cum_max*60
real_time_available
ref = 3
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
ppert (real_min_available/60, cum_min, cum_most_likely, cum_max)
ref = 4
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
ppert (real_min_available/60, cum_min, cum_most_likely, cum_max)
ref = 5
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
ppert (real_min_available/60, cum_min, cum_most_likely, cum_max)
ref = 6
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
ppert (real_min_available/60, cum_min, cum_most_likely, cum_max)
ref = 7
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
ppert (real_min_available/60, cum_min, cum_most_likely, cum_max)
start = time_now #"2020-04-29 11:00:00"
prob_hit_deadline = NULL
for (i in 1:nrow (tasks)){
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
prob_hit_deadline = c(prob_hit_deadline, ppert (real_min_available/60, cum_min, cum_most_likely, cum_max))
}
start = "2020-04-29 11:00:00"
prob_hit_deadline = NULL
for (i in 1:nrow (tasks)){
finish = tasks$task_finish [ref] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:ref])
cum_min = sum (tasks$Min_Hours [1:ref])
cum_max = sum (tasks$Max_Hours [1:ref])
real_min_available = real_time_delta_mins (start, finish, ooos)
prob_hit_deadline = c(prob_hit_deadline, ppert (real_min_available/60, cum_min, cum_most_likely, cum_max))
}
prob_hit_deadline
start = "2020-04-29 11:00:00"
prob_hit_deadline = NULL
for (i in 1:nrow (tasks)){
finish = tasks$task_finish [i] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:i])
cum_min = sum (tasks$Min_Hours [1:i])
cum_max = sum (tasks$Max_Hours [1:i])
real_min_available = real_time_delta_mins (start, finish, ooos)
prob_hit_deadline = c(prob_hit_deadline, ppert (real_min_available/60, cum_min, cum_most_likely, cum_max))
}
prob_hit_deadline
tasks
start = time_now #"2020-04-29 11:00:00"
prob_hit_deadline = NULL
for (i in 1:nrow (tasks)){
finish = tasks$task_finish [i] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:i])
cum_min = sum (tasks$Min_Hours [1:i])
cum_max = sum (tasks$Max_Hours [1:i])
real_min_available = real_time_delta_mins (start, finish, ooos)
prob_hit_deadline = c(prob_hit_deadline, ppert (real_min_available/60, cum_min, cum_most_likely, cum_max))
}
prob_hit_deadline
tasks
start = time_now #"2020-04-29 11:00:00"
prob_hit_deadline = NULL
for (i in 1:nrow (tasks)){
finish = tasks$Deadline [i] #"2020-05-08 17:00:00"
cum_most_likely = sum (tasks$Most_Likely_Hours [1:i])
cum_min = sum (tasks$Min_Hours [1:i])
cum_max = sum (tasks$Max_Hours [1:i])
real_min_available = real_time_delta_mins (start, finish, ooos)
prob_hit_deadline = c(prob_hit_deadline, ppert (real_min_available/60, cum_min, cum_most_likely, cum_max))
}
prob_hit_deadline
start = "2020-04-29 11:00:00"
prob_hit_deadline = NULL
for (i in 1:nrow (tasks)){
finish = tasks$Deadline [i]
cum_most_likely = sum (tasks$Most_Likely_Hours [1:i])
cum_min = sum (tasks$Min_Hours [1:i])
cum_max = sum (tasks$Max_Hours [1:i])
real_min_available = real_time_delta_mins (start, finish, ooos)
prob_hit_deadline = c(prob_hit_deadline, ppert (real_min_available/60, cum_min, cum_most_likely, cum_max))
}
prob_hit_deadline
tasks
library("reticulate")
reticulate::conda_python("shiny_time")
cal <- source_python ("get_calendar.py")
